---
title: "Práctica 2 - Limpieza y análisis de datos"
author:
- Pablo López Ladrón de Guevara
- Rafael Corvillo Alonso
date: "17/05/2021"
output:
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 2
    includes:
      in_header: PEC-header.html
  pdf_document:
    highlight: zenburn
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load_libraries, include=FALSE}
library(car)
library(rminer)
library(rpart)
library(rpart.plot)
library(caret)
library(ggplot2)
library(grid)
library(gridExtra)
library(corrplot)
```

\pagebreak

******
# Descripción del dataset.
******

El conjunto de datos utilizado es el correspondiente a la competición Kaggle del hundimiento del Titanic. El objetivo es predecir si un pasajero sobrevivió o no al hundimiento del Titanic. El dataset contiente los siguientes atributos:

* **PassengerId**: Identificador único del pasajero.

* **Survived**: Es la variable objetivo que se pretende predecir. Si el pasajero sobrevivió al naufragio, codificada como 0 (no) y 1 (si).

* **Pclass**: Clase en la que viaja el pasajero: Primera segunda o tercera (1, 2, 3)

* **Name**: Nombre del pasajero.

* **Sex**: Sexo del pasajero.

* **Age**: Edad del pasajero. Pueden tener números decimales, refiriéndose con ellos a los meses.

* **SibSp**: Número de los siguientes tipos de familiares que viajan en el barco con el pasajero:
  * Hermanos/as
  * Hermanastros/as
  * Marido/esposa (no se tiene en cuenta amantes o prometidas)

* **Parch**: Número de los siguientes tipos de familiares que viajan en el barco con el pasajero:
  * Padres/madres
  * Hijos/as
  * Hijastros/as
  * En el caso de que el niño viaje con una niñera, no se contará a la niñera como familiar.

* **Ticket**: Identificador del billete.

* **Fare**: Precio pagado por el billete.

* **Cabin**: Número de camarote.

* **Embarked**: Puerto de embarque el pasajero.


\pagebreak

******
# Integración y selección de los datos de interés a analizar.
******

En Kaggle existen dos archivos. Un archivo de entremaniento y otro de test. Este último se utiliza para aplicar el modelo y participar en la competición. A lo largo de esta práctica trabajaremos únicamente con el archivo de entrenamiento. Esto es debido a que el archivo de test no contiene la variable objetivo "Survived", la cual será necesaria para algunos métodos en el apartado de análisis como el como el contraste de hipótesis o .

Si abrimos el archivo con un editor de texto como Notepad++ vemos se utiliza codificación UTF-8 sin BOM. Así que lo leemos con codificación 'UTF-8'.

```{r Carga del conjunto de datos}
# Carga del conjunto de datos
titanic_data <- read.csv('train.csv', fileEncoding = 'UTF-8')

# Comprobamos que se carga correctamente
head(titanic_data)

# Dimensiones de los datos
dim(titanic_data)
```

El conjunto de datos tiene 12 atributos y 891 registros.

Observamoslas caracaterísticas de cada variable mediante la función summary() y str()

```{r}
summary(titanic_data)
```

```{r}
str(titanic_data)
```

## Selección de los datos interés

Las variables con el nombre y el número de Ticket no aportarán ninguna información de interés de cara a saber si un pasajero sobrevive o no. Y en el remoto caso de que se pueda sacar alguna información importante por el apellido, tenemos la misma información de forma más completa en las variables SibSp y Parch.

```{r}
drop_data <- names(titanic_data) %in% c("Name", "Ticket")

titanic_data <- titanic_data[,!drop_data]
```

## Conversión cadena de caracteres a factor

Convertimos los atributos categóricos en tipo factor. La variable PClass fue clasificada como tipo int al leer el datase, pero en realidad solo toma tres valores (Las tres clases antes comentadas).

```{r Conversión de variables}
titanic_data$Survived <- as.factor(titanic_data$Survived)
titanic_data$Pclass <- as.factor(titanic_data$Pclass)
titanic_data$Sex <- as.factor(titanic_data$Sex)
titanic_data$Embarked <- as.factor(titanic_data$Embarked)
```
\pagebreak

******
# Limpieza de los datos
******

## Datos Perdidos.

Mostramos el número de NAs en cada uno de los atributos del conjunto de datos.

```{r}
colSums(is.na(titanic_data))
```

La única variable wue contiene NAs es Age con 177 NAs.

Comprobamos a continuación si existen cadenas de caracteres vacías. 

```{r}
colSums(titanic_data=="")
```

Tanto en la variable Cabin como en Embarked encontramos datos perdidos de estas características. En el atributo Cabin existen 687 cadenas de caracteres vacías y Embarked contiene 2.

Los datos perdidos encontrados en las variables comentadas, se tratarán de forma diferente según las características de la variable o la cantidad de datos perdidos. Si las aproximaciones utilizadas para limpiar los datos son los correctos o no, no se sabe hasta que se implementan los modelos. Si no se consiguen los resultados deseados, una posibilidad para intentar mejorar el modelo es volver a este apartado y gestionar de forma diferente el tratamiento de elementos vacíos.

Primero tratamos los datos vacíos de la variable Embarked. En este caso solo existen 2 elementos vacíos. Una primera posibilidad sería eliminar completamente esos dos registros. Pero con el objetivo de no perder información, imputaremos estos dos registros con la moda estadística de la variable. Para ello creamos la función getmode() que nos devuelve el valor más frecuente de una variable.

```{r}
getmode <- function(v) {
   uniqv <- unique(v)
   uniqv[which.max(tabulate(match(v, uniqv)))]
}

Embarked_mode <- getmode(titanic_data$Embarked)
```

Sustituimos los valores perdidos por la moda calculada.

```{r}
titanic_data$Embarked[titanic_data$Embarked == ""] <- Embarked_mode
```

En la variable Cabin el número de elementos vacíos es muy elevado, 687 de un total de 891 registros (77,1%). Debido a este alto porcentaje de elementos vacíos, una primera posibilidad sería sustitur las cadenas vacías por una constante como "Desconocido". Pero en lugar de ello optaremos por eliminar por completo la variable. Tiene sentido debido al elevado número de valores vacíos y a que el atributo Pclass nos puede dar una información similar de cara a saber si un pasajero sobrevive o no. Los camarotes de primera clase estarían situados cerca de cubierta, siendo la probabilidad de sobrevivir mayor que la de un pasejero que viaje en tercera clase y cuyo camarote se encuentre en una planta muy inferior.

```{r}
titanic_data <- titanic_data[,-9]
```


Por último, tratamos la variable age. Para imputar los valores perdidos de las edades de los pasajeros utilizamos una aproximación similar a la aplicada con la variable Fare. Pero para intentar ser un poco más precisos, dividiremos el conjunto de datos en seis grupos y e imputaremos con la mediana de cada grupo. Los atributos elegidos para crear los grupos serán la clase en la que viaja el pasajero y el sexo. Como veremos en el aparatado de análisis, estas dos variables serán importantes a la hora de decidir si un pasajero sobrevive o no.

Creamos con ayuda de la función tapply() la matriz con las medianas de las edades en los grupos comentados.

```{r}
Age_median_matrix <- tapply(titanic_data$Age, list(titanic_data$Pclass, titanic_data$Sex), median, na.rm = TRUE)
```

Mostramos la matriz.

```{r}
Age_median_matrix
```

Se observa que hay diferencia entre las medianas de los diferentes grupos. Con esto corroboramos que ha sido una aproximación acertada hacerlo de esta manera.

Sustituimos los elementos vacíos de edad con los valores correspondientes de la matriz de medianas calculadas.

```{r}
titanic_data$Age[is.na(titanic_data$Age) & titanic_data$Sex == "female" & titanic_data$Pclass == "1"] <- Age_median_matrix[1,1]

titanic_data$Age[is.na(titanic_data$Age) & titanic_data$Sex == "female" & titanic_data$Pclass == "2"] <- Age_median_matrix[2,1]

titanic_data$Age[is.na(titanic_data$Age) & titanic_data$Sex == "female" & titanic_data$Pclass == "3"] <- Age_median_matrix[3,1]

titanic_data$Age[is.na(titanic_data$Age) & titanic_data$Sex == "male" & titanic_data$Pclass == "1"] <- Age_median_matrix[1,2]

titanic_data$Age[is.na(titanic_data$Age) & titanic_data$Sex == "male" & titanic_data$Pclass == "2"] <- Age_median_matrix[2,2]

titanic_data$Age[is.na(titanic_data$Age) & titanic_data$Sex == "male" & titanic_data$Pclass == "3"] <- Age_median_matrix[3,2]
```

## Valores extremos.

Mostramos los diagramas de cajas de las variables contínuas del dataset, Age y Fare, para comprobar si existen outliers.

Comenzamos observando el atributo correspondiente al precio de los billetes.

```{r}
boxplot(titanic_data$Fare, main = "Fare")
```

Utilizamos la función boxplot.stats() para obtener las estadísticas de forma numérica.

```{r}
boxplot.stats(titanic_data$Fare)$stats
```

Existen valores extremos por encima del bigote superior del boxplot (65). La distribución de esta variable está muy desplazada a la izquierda. Esto es debido a que el 50% de los datos se encuentran entre 7,89 y 31,27. Pero se vendieron billetes muy por encima de esos precios. Esta desigualdad en los precios es plausible, ya que al tratarse del viaje inaugural de un transatlántico de lujo, pudo haber diferentes paquetes de precios con diferentes características.Los paquetes más lujosos estarían destinados para los pasajeros más selectos. Un ejemplo sería el billete con un precio cercano a los 500$. Se diferencian mucho del resto, pero pueden corresponder a la suit más lujosa del barco. 

Vemos cuántos ouliers son identificados mediante el diagrama de caja.

```{r}
length(titanic_data$Fare[titanic_data$Fare > 65])
```

Aunque estos 166 registros son posibles como ya hemos comentado, los trataremos de cara a mejorar el funcionamiento de los modelos que se elaborarán. A la hora de tratar los outliers, se pueden realizar imputación de datos como en el caso de los datos perdidos. En este caso realizaremos la técnica llamada Capping. Imputamos los outliers por encima del bigote superior con dicho valor.

```{r}
titanic_data$Fare[titanic_data$Fare > 65] <- 65
```

Mostramos el nuevo diagrama boxplot sin valores extremos.

```{r}
boxplot(titanic_data$Fare, main = "Fare")
```

Analizamos a continuación los valores extremos del atributo correspondiente a la edad de los pasajeros.

```{r}
boxplot(titanic_data$Age, main = "Age")
```

Se vuelven a observar valores extremos por encima del bigotes superior del gráfico.Como en el caso anterior es totalmente posible que viajen personas por encima de 60 años. Una posible sería no hacer nada con estos outliers para no perder información. En su lugar, optaremos por discretizar la variable. Aunque decidimos mantener la variable original, para poder utilizarla en algunos subapartados del análisis. 

Para la discretación, hemos decididos crear cinco niveles de frecuencia parecida. Mostramos el histograma del atributo para ver cómo se distribuye. Mostramos agrupaciones de dos en dos, para obaservarlo con más detalle. 

```{r}
hist(titanic_data$Age,breaks = 40)
```
Lo primero que se observa, es que gran parte de los datos se concentran en tre 20 y 40. Por lo que en ese rango habrá más niveles.

Al existir un total de 891 registros en el conjunto de datos y querer discretizar la edad en 5 niveles, el objetivo será obtener aproximadametne 178 registros en cada nivel. observando el histograma y probando diferetentes límites, los cinco niveles de discretización serán los siguientes:

* Joven: [0,19]
* Joven-Adulto: [20,24]
* Adulto: [25,28]
* Adulto-Mayor: [29,39] 
* Mayor: [40,80]

Para ello utilizamos la función cut(). Activamos la opción ordered_result ya que existe un orden de menor a mayor entre los niveles establecidos.

```{r}
titanic_data$Age_d <- cut(titanic_data$Age, breaks = c(0,19,24,28,39,80), ordered_result = TRUE, labels = c("Joven", "Joven-Adulto", "Adulto", "Adulto-Mayor","Mayor"))
```

Comprobamos gráficamente que la variable discretizada se distribuye de manera similar en cada uno de sus niveles.

```{r}
plot(titanic_data$Age_d)
```

******
# Análisis de los datos
******

## Selección de los grupos de datos que se quieren analizar/comparar (planificación de los análisis a aplicar)

AQUI HAY QUE SELECCIONAR LOS GRUPOS DE DATOS QUE VAMOS A ANALIZAR Y PLANIFICAR LOS ANÁLISIS (PREGUNTAS A RESPONDER)

```{r Variables cuantitativas}
titanic_data.cuant <- titanic_data[, c("Age", "SibSp", "Parch", "Fare")]
```


## Comprobación de la normalidad y homogeneidad de la varianza

Para comprobar la normalidad de las variable cuantitativas vamos a utilizar el test de Shapiro-Wilk, ya que se considera uno de los métodos más potentes para contrastar la normalidad. Este método se basa en el contraste de hipótesis, asumiendo como hipótesis nula que la población sigue una distribución normal. Por tanto, nos basaremos en el *p-valor* para determinar si aceptamos o rechazamos la hipótesis nula.

```{r Test de normalidad Shapiro-Wilk}
# Test de normalidad de las variables cuantitativas
shapiro.test(titanic_data$Age)
shapiro.test(titanic_data$SibSp)
shapiro.test(titanic_data$Parch)
shapiro.test(titanic_data$Fare)
```

Si usamos un nivel de significancia de $\alpha=0.05$, podemos ver que en todos los tests anteriores se rechaza la hipótesis nula con un nivel del confianza del 95%, ya que $p\_valor<0.05$ en todos los tests. Por tanto, podemos decir que las variables cuantitativas de este conjunto de datos (`Age`, `SibSp`, `Parch` y `Fare`) no siguen una distribución normal. Vamos a comparar las distribuciones de estas variables con la de una normal de forma visual mediante un gráfico QQ.

```{r Gráfico QQ}
# Gráficos QQ
qqnorm(titanic_data.cuant$Age, main = "QQ plot Age", col = 'blue')
qqline(titanic_data.cuant$Age)

qqnorm(titanic_data.cuant$SibSp, main = "QQ plot SibSp", col = 'blue')
qqline(titanic_data.cuant$SibSp)

qqnorm(titanic_data.cuant$Parch, main = "QQ plot Parch", col = 'blue')
qqline(titanic_data.cuant$Parch)

qqnorm(titanic_data.cuant$Fare, main = "QQ plot Fare", col = 'blue')
qqline(titanic_data.cuant$Fare)
```

Comprobamos que, como hemos obtenido con el test de Shapiro-Wilk, las variables cuantitativas no siguen una distribución normal. Vemos que la variable `Age` se encuentra cerca de la normalidad, por tanto, como tenemos una cantidad de observaciones suficientemente grande podemos asumir que esta variable sigue una distribución normal basándonos en el teorema central del límite.

Ahora vamos a comprobar la homocedasticidad para las variables anteriores diferenciando en distintos grupos. Para la variable `Age`, como hemos supuesto normalidad, usaremos el test de Levene y para el resto de variables usaremos el test de Fligner-Killeen. Ambas pruebas realizan un contraste de hipótesis donde la hipótesis nula asume igualdad de varianzas en los diferentes grupos de datos.

```{r Test de homocedasticidad para Age}
# Comprobación de la homocedasticidad para Age
leveneTest(Age ~ Pclass, data = titanic_data)
leveneTest(Age ~ Sex, data = titanic_data)
leveneTest(Age ~ Embarked, data = titanic_data)
leveneTest(Age ~ Survived, data = titanic_data)
```

De los resultados de los tests de Levene podemos decir que la variable `Age` presenta herocedasticidad con las variables `Pclass`, `Embarked` y `Survived`, y homocedasticidad con la variable `Sex`. Por tanto, la variable `Age` tendrá varianzas iguales entre los pasajeros de distintos sexo. En cambio habrá distinta varianza de la variable `Age` entre los pasajeros que sobrevivieron y los que no o entre las distintas clases.

Para comprobar la homocedasticidad en las variables `SibSp` y `Parch` vamos a sumarlas y usar una variable que indique el número de familiares que iban a bordo del Titanic.

```{r Test de homocedasticidad para SibSp+Parch}
# Comprobación de la homocedasticidad para SibSp+Parch
fligner.test(SibSp+Parch ~ Pclass, data = titanic_data)
fligner.test(SibSp+Parch ~ Sex, data = titanic_data)
fligner.test(SibSp+Parch ~ Embarked, data = titanic_data)
fligner.test(SibSp+Parch ~ Survived, data = titanic_data)
```

Como podemos ver el tamaño de la familia tendrá igualdad de varianzas (homocedasticidad) en las diferentes clases (`Pclass`) y en el puerto de embarque (`Embarked`). En cambio, presenta varianzas distintas (heterocedasticidad) entre hombres y mujeres y entre los pasajeros que sobrevivieron y los que no.

```{r Test de homocedasticidad para Fare}
# Comprobación de la homocedasticidad para Fare
fligner.test(Fare ~ Pclass, data = titanic_data)
fligner.test(Fare ~ Sex, data = titanic_data)
fligner.test(Fare ~ Embarked, data = titanic_data)
fligner.test(Fare ~ Survived, data = titanic_data)
```

Vemos que la variable `Fare` presenta heterocedasticidad entre las distintas clases, entre hombre y mujeres, entre los distintos puertos de embarque y entre los pasajeros que sobrevivieron y los que no.

Para terminar vamos a ver la relación de la variable `Survived` con el resto de variables que estamos analizando, tanto cuantitativas como categóricas. Hemos visto que la variable `Age` es la única para la que se ha asumido normalidad pero presenta heterocedasticidad para la variable `Survived`. Por tanto, para todas las variables cuantitativas tendremos que utilizar pruebas no paramétricas como Wilcoxon (datos dependientes) o Mann-Whitney (datos independientes). Estas dos pruebas se aplican indistintamente con la función `wilcox.test()`.

```{r Relación de Survived con las variable cuantitativas}
# Relación de Survived con las variable cuantitativas
wilcox.test(Age ~ Survived, data = titanic_data)
wilcox.test(SibSp+Parch ~ Survived, data = titanic_data)
wilcox.test(Fare ~ Survived, data = titanic_data)
```

De acuerdo a los resultados anteriores podemos decir que se observan diferencias estadísticamente significantivas en la edad, en el tamaño de la familia y en el precio del ticket de los pasajeros que sobrevivieron y los que no.

Para comparar si existen diferencias significativas en las variable categóricas entre los pasajeros que sobrevivieron y los que no vamos a aplicar el test de $\chi^2$.

```{r Relación de Survived con las variable categóricas}
# Relación de Survived con las variable categóricas
table.Pclass <- table(titanic_data$Pclass, titanic_data$Survived)
table.Pclass
chisq.test(table.Pclass)

table.Sex <- table(titanic_data$Sex, titanic_data$Survived)
table.Sex
chisq.test(table.Sex)

table.Embarked <- table(titanic_data$Embarked, titanic_data$Survived)
table.Embarked
chisq.test(table.Embarked)
```

con estos resultados comprobamos que se rechaza la hipótesis nula para los tres casos, por tanto, observamos que tanto el sexo, como la clase y el puerto de embarque tuvieron repercusión en si un pasajero finalmente sobrevivió al accidente o no.

AÑADIR TAMBIÉN ANÁLISIS DE CORRELACIONES

## Modelo supervisado 

**Preparación datos de entrenameniento y test**

Como se comentó en el primer apartado, los datos originales obtenidos de Kaggle ya estaban dividos en datos de entrenamiento y test. El dataset de entremaniento es el único que contiene la variable objetivo "survived". Por eso estamos trabajando únicamente con este conjunto de datos para poder observar la precisión del modelo creado.

Dividimos por la tanto el conjunto de datos en dos, 2/3 de los datos se enfocarán a entrenamiento y 1/3 para test. se realiza la división mediante el método de exclusión con partición estratificada para que la proporción de pasajeros que sobreviven frente a los que no sea similar en ambos conjunto de datos. Utilizamos la función holdout de la librería rminer.

```{r}
# Hacemos uso de seed para que el mismo resultado sea reproducible
set.seed(10)
h<-holdout(titanic_data$Survived,ratio=2/3,mode="stratified")
titanic_train<-titanic_data[h$tr,]
titanic_test<-titanic_data[h$ts,]
```

Comprobamos que la variable objetivo se ha repartido de manera similar en ambos conjuntos de datos.

```{r}
prop.table(table(titanic_train$Survived))
```

```{r}
prop.table(table(titanic_test$Survived))
```

La proporción es exactamente la misma.

**Árbol de descisión**

Entrenamos el árbol de desición utilizando la función rpart(). 

```{r}
set.seed(20)
mod_dt <- rpart(Survived~., data = titanic_train, method = 'class')
```

Mostramos el árbol de decisión calculado

```{r}
rpart.plot(mod_dt)
```

Las varibales Age, SibSp, Fare, Pclass y Sex son utililzadas para generar el árbol de decisión.

Para saber como de bueno es el modelo, predecimos la supervivienia de los pasajeros del conjunto de datos de test.

```{r}
set.seed(30)
pred_dt <- predict(mod_dt, newdata = titanic_test, type = "class")
```

Mostramos la matriz de confusión.

```{r}
confusionMatrix(pred_dt,titanic_test$Survived,positive="1")
```

La precisión que nos da el modelo es de 78,19 %. El 78,19% de los registros han sido correctamente clasificados.

La función confusionMatrix() también nos facilita otros valores como la sensibilidad (tasa de verdaderos positivos) o la especifidad (tasa de verdaderos negativos). Estos valores son 60,53% y 90,16% respectivamente. Es decir, el modelo es mejor prediciendo correctamente registros negativos que positivos.


**Random Forest**

Calculamos un modelo Random Forest con una validación cruzada con 4 folds.

Mediante la función train_control, especificamos las características comentadas del proceso de entrenamiento para crear el modelo.

```{r}
train_control<- trainControl(method="cv", number=4)
```

Creamos el modelo.

```{r}
set.seed(31)
mod_rf<-train(Survived~., data=titanic_train, method="rf", trControl = train_control)
```

Predecimos la variable objetivo con los datos del conjunto de test.

```{r}
set.seed(32)
pred_rf <- predict(mod_rf, newdata=titanic_test)
```

Observamos la matriz de confusión.

```{r}
confusionMatrix(pred_rf,titanic_test$Survived,positive="1")
```

Con el modelo randon forest el 80,13 % de los registros de test fueron correctamente clasificados.La precisión de este modelo ha aumentado casi 2% respecto al árbol de decisión.

La sensibilidad de este modelo es 67,54% y su especificidad 87,98%. Si comparamos estos valores con los obtenidos mediante el árbol de decison, se obtiene que el modelo randon forest clasifica algo peor los pasajeros que no sobrevivieron, pero en cambio, los pasajeros que si sobrebivieron son clasificados con un porcentaje bastante mayor correctamente.

******
# Representación de los resultados a partir de tablas y gráficas.
******

A lo largo de la práctica se ha hecho uso de diferentes tipos de gráficas para comprender mejor los datos y analizarlos. En el apartado anterior por ejemplo, se mostró el árbol de decisión gráficamente para saber que variables utilizaba en la toma de decicisones. También hemos usado gráficos QQ para comprobar la normalidad de algunas variables, diagramas de caja para observar los valores extremos o histogramas para ver la distribución de la variable Age. En este apartado mostraremos algunos ejemplos más para entender mejor el conjunto de datos.

Primeramente se vuelve a mostrar el histograma de la edad de los pasajeros (sin descretizar), pero esta vez añadimos la información si sobreviven o no. Esta vez utlizaremos la función ggplot. 

```{r}
ggplot(data = titanic_data[!(is.na(titanic_data[1:filas,]$Age)),],aes(x=Age,fill=Survived))+geom_histogram(binwidth =3)
```

Como ya se observó en su momento, la mayoría de pasajeros se encuentran entre los 20 y cuarenta años. También se observa que la tasa de superviviencia entre los pasajeros menores es bastante alta. Mientras que en los pasajeros entorno a los 25 años sobrebieron pocos en relación al número total de personas de esa edad (Unos 30 de más de 150).

Mostramos ahora un gráfico de barras con el número de pasajeros por edad y la información de si sobrebieron al accidente.

```{r}
ggplot(data=titanic_data,aes(x=Sex,fill=Survived))+geom_bar()
```

El número de pasajeros varones es casi el doble que el de mujeres. Pero la proporción de mujeres que sobrevivieron es mucho mayor que la de hombres.

Para observar con más detalle las proporciones de las gráficas anteriores, mostramos a continuación las tres variables en una serie de gráficas de frecuencia. Pero en este caso utilizaremos la varible edad discretizada.

```{r}
ggplot(data = titanic_data[1:filas,],aes(x=Sex,fill=Survived))+geom_bar(position="fill")+facet_wrap(~Age_d)
```

En todas las edades se observa una gran desigualdad entre el índice de superviviencia si se comparan hombres con mujeres. Las mujeres se mantienen entorno al 75%, mientras que los hombres no llegan casi ni al 25%. Dentro de la edad joven, que comprende pasajeros por debajo de 20 años, es la única en la que la proporción de pasajeros masculinos que sobreviven sobrepasa (por poco) ese 25%. La menor frecuencia de pasajeros salvados tanto en mujeres como en hombres, la encontramos entre la categoría de edad Joven-Adulto. Este nivel de Age abarca pasajeros entre los 20 y los 24 años.

Mostramos una gráfica similar pero este caso nos interesa analizar la supervivencia de los pasajeros respecto a la clase en la que viajaron y el muelle donde embarcaron.

```{r}
ggplot(data = titanic_data[1:filas,],aes(x=Embarked,fill=Survived))+geom_bar(position="fill")+facet_wrap(~Pclass)
```

Lo primero que se observa es que la tasa de pasajeros salvados es mucho menor en los pasajeros de tercera clase. En cambio, no existe una gran diferencia entre los de segunda y tercera clase, aún así el índice de superviviencia es algo mayor dentro de primera clase. Otro dato curioso a destacar, es que la frecuencia de superviviencia varía bastante dependiendo del muello de embarque.

comparamos mediante dos diagramas de barras colocados uno junto al otro, la variables que indican la información familiar SibSp y Parch.

```{r}
grid.newpage()
Graf1 <- ggplot(data = titanic_data,aes(x=SibSp,fill=Survived))+geom_bar()+theme(legend.position="none")
Graf2 <- ggplot(data = titanic_data,aes(x=Parch,fill=Survived))+geom_bar()

grid.arrange(Graf1, Graf2, ncol=2)
```

La gran parte de pasajeros viajó sin familiares. Pero se observa qeu la forma de ambas gráficas son similares. Esto puede indicar la presencia de correlaciones. Para ver sie esto es así mostraremos la matriz de correlación de estas dos variables y añadimos tambíén la variable contínua Age.

Debemos trabajar con variables numéricas, así que convertimos los datos correspondientes y preparamos el conjunto de datos.

```{r}
titanic_data_num <- titanic_data[,c("Age", "SibSp", "Parch")]

titanic_data_num$Age <- as.numeric(titanic_data_num$Age)
titanic_data_num$SibSp <- as.numeric(titanic_data_num$SibSp)
titanic_data_num$Parch <- as.numeric(titanic_data_num$Parch)
```

Mostramos la matriz de correlación gráficamente con ayuda de la función corrplot.

```{r}
correlacion <- round(cor(titanic_data_num),1)
corrplot(correlacion, method="number", type="upper")
```

Se ve que existe algo de correlación positiva entre las variables SibSp y Parch, aunque no tan fuerte como se esperaba por la similitud de las gráficas. ESta correlación es lógica, ya que si un hombre o una mujer viaja con hijos, es bastante probale que también viaje con su marido o mujer.
